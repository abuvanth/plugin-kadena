{"version":3,"sources":["../src/actions/transfer.ts","../src/providers/wallet.ts","../src/kadenaGraphClient.ts","../src/actions/utils.ts","../src/constants.ts","../src/actions/getbalance.ts","../src/actions/swap.ts","../src/index.ts"],"sourcesContent":["import { elizaLogger } from \"@elizaos/core\";\nimport {\n    type ActionExample,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport { composeContext, generateObjectDeprecated } from \"@elizaos/core\";\nimport { walletProvider } from \"../providers/wallet\";\nimport { restoreKeyPairFromSecretKey } from \"@kadena/cryptography-utils\";\nimport { Pact, isSignedTransaction, readKeyset } from '@kadena/client';\nimport { signTransaction, isXchainV1 } from \"./utils\";\nimport { getClient } from \"../constants\";\n\nexport interface TransferContent extends Content {\n    recipient: string;\n    amount: string | number;\n    fromChain?: string;\n    toChain?: string;\n}\n\nfunction isTransferContent(content: unknown): content is TransferContent {\n    elizaLogger.debug(\"Validating transfer content:\", content);\n    const c = content as TransferContent;\n    return (\n        typeof c.recipient === \"string\" && c.recipient.startsWith(\"k:\") &&\n        (typeof c.amount === \"string\" || typeof c.amount === \"number\") &&\n        parseFloat(c.amount.toString()) > 0 &&\n        (typeof c.fromChain === \"string\" || typeof c.fromChain === \"undefined\") &&\n        (typeof c.toChain === \"string\" || typeof c.toChain === \"undefined\")\n    );\n}\n\nconst networkId = \"mainnet01\"; // Could be made configurable via runtime settings\n\nconst transferTemplate = `You are processing a token transfer request. Extract parameters from the message.\n\nExample requests:\n1. Single-chain: \"send 5 KDA to k:123 on chain 2\"\n2. Cross-chain: \"transfer 3 KDA from chain 1 to chain 3\"\n\nResponse format:\n\\`\\`\\`json\n{\n    \"recipient\": \"k:...\",\n    \"amount\": \"5\",\n    \"fromChain\": \"1\",\n    \"toChain\": \"3\"\n}\n\\`\\`\\`\n\nRules:\n1. Recipient must start with \"k:\"\n2. Amount must be numeric\n3. fromChain required for cross-chain transfers\n4. toChain defaults to fromChain if omitted\n5. Chain IDs must be 0-20\n\nRecent messages:\n{{recentMessages}}\n\nExtract and return JSON with:\n- recipient\n- amount\n- fromChain (optional)\n- toChain (optional)`;\n\nexport const transferToken: Action = {\n    name: \"TRANSFER_KDA\",\n    similes: [\n        \"CROSS_CHAIN_TRANSFER\",\n        \"SEND_TO_CHAIN\",\n        \"TRANSFER_BETWEEN_CHAINS\"\n    ],\n    triggers: [\n        \"send kda\",\n        \"transfer kda\",\n        \"cross-chain transfer\",\n        \"send from chain\",\n        \"transfer between chains\",\n        \"send to chain\"\n    ],\n    shouldHandle: (message: Memory) => {\n        const text = message.content?.text?.toLowerCase() || \"\";\n        return (\n            (text.includes(\"send\") || text.includes(\"transfer\")) &&\n            text.includes(\"kda\") &&\n            text.includes(\"chain\")\n        );\n    },\n    validate: async (_runtime: IAgentRuntime, message: Memory) => {\n        elizaLogger.debug(\"Validating transfer for user:\", message.userId);\n        return true;\n    },\n    priority: 1000,\n    description: \"Transfer KDA tokens between chains on the Kadena network\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.info(\"Starting transfer handler for:\", message.content?.text);\n\n        try {\n            const secretKey = runtime.getSetting(\"KADENA_SECRET_KEY\");\n            if (!secretKey) throw new Error(\"KADENA_SECRET_KEY not configured\");\n\n            const network = runtime.getSetting(\"KADENA_NETWORK\") || networkId;\n            const defaultChain = runtime.getSetting(\"DEFAULT_CHAIN\") || \"1\";\n            const keypair = restoreKeyPairFromSecretKey(secretKey);\n            const account = `k:${keypair.publicKey}`;\n\n            const walletInfo = await walletProvider.get(runtime, message, state);\n            state.walletInfo = walletInfo;\n\n            const currentState = state ? \n                await runtime.updateRecentMessageState(state) :\n                (await runtime.composeState(message)) as State;\n\n            const transferContext = composeContext({\n                state: currentState,\n                template: transferTemplate,\n            });\n\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: transferContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (!isTransferContent(content)) {\n                throw new Error(\"Invalid transfer parameters\");\n            }\n\n            const fromChain = content.fromChain || defaultChain;\n            const toChain = content.toChain || fromChain;\n            const isCrossChain = fromChain !== toChain;\n            const amount = { decimal: parseFloat(content.amount.toString()).toFixed(12) };\n\n            const validChains = Array.from({ length: 20 }, (_, i) => i.toString());\n            if (!validChains.includes(fromChain) || !validChains.includes(toChain)) {\n                throw new Error(\"Invalid chain ID (must be 0-19)\");\n            }\n\n            const sourceClient = getClient(network, fromChain);\n            let requestKey: string;\n\n            if (isCrossChain) {\n                const targetClient = getClient(network, toChain);\n                const supportsXchainV1 = await isXchainV1('coin',network);\n\n                // Step 1: Initiate cross-chain transfer\n                const transferTx = Pact.builder\n                    .execution(\n                        Pact.modules['coin'].defpact[\"transfer-crosschain\"](\n                            account,\n                            content.recipient,\n                            readKeyset('ks'),\n                            toChain,\n                            amount\n                        )\n                    )\n                    .addSigner(keypair.publicKey, (withCap) => {\n                        const caps = [];\n                        if (supportsXchainV1) {\n                            caps.push(withCap(\"coin.GAS\"))\n                            caps.push(\n                                withCap(\"coin.TRANSFER_XCHAIN\",\n                                    account,\n                                    content.recipient,\n                                    amount,\n                                    toChain\n                                )\n                            );\n                        }\n                        return caps;\n                    })\n                    .addKeyset('ks', 'keys-all', content.recipient.slice(2))\n                    .setMeta({\n                        chainId: fromChain,\n                        senderAccount: account,\n                        gasLimit: 2500,\n                        gasPrice: 0.00000001,\n                        ttl: 28800\n                    })\n                    .setNetworkId(network)\n                    .createTransaction();\n\n                const signedTransfer = await signTransaction(transferTx, keypair);\n                if (!isSignedTransaction(signedTransfer)) {\n                    throw new Error(\"Failed to sign source chain transaction\");\n                }\n\n                const localResult = await sourceClient.local(signedTransfer, {\n                    signatureVerification: true,\n                    preflight: true\n                });\n                if (localResult.result.status !== \"success\") {\n                    throw new Error(`Local verification failed: ${JSON.stringify(localResult.result.error)}`);\n                }\n\n                const submitResult = await sourceClient.submit(signedTransfer);\n                requestKey = submitResult.requestKey;\n\n                // Wait for confirmation\n                const pollResult = await sourceClient.pollOne(submitResult);\n                if (pollResult.result.status !== \"success\") {\n                    throw new Error(`Source chain transaction failed: ${JSON.stringify(pollResult.result.error)}`);\n                }\n\n                // Step 2: Get SPV proof and complete on target chain\n                const spvProof = await sourceClient.pollCreateSpv(submitResult, toChain);\n                \n                const continuationTx = Pact.builder\n                    .continuation({\n                        pactId: pollResult.continuation?.pactId || '',\n                        rollback: false,\n                        step: 1,\n                        proof: spvProof\n                    })\n                    .addSigner(keypair.publicKey, (withCap) => [\n                        withCap(\"coin.GAS\")\n                    ])\n                    .setMeta({\n                        chainId: toChain,\n                        senderAccount: 'kadena-xchain-gas',\n                        gasLimit: 850,\n                        gasPrice: 0.00000001,\n                        ttl: 28800\n                    })\n                    .setNetworkId(network)\n                    .createTransaction();\n\n                const signedContinuation = await signTransaction(continuationTx, keypair);\n                if (!isSignedTransaction(signedContinuation)) {\n                    throw new Error(\"Failed to sign continuation transaction\");\n                }\n\n                const contLocalResult = await targetClient.local(signedContinuation);\n                if (contLocalResult.result.status !== \"success\") {\n                    throw new Error(`Continuation preflight failed: ${JSON.stringify(contLocalResult.result.error)}`);\n                }\n\n                const contSubmitResult = await targetClient.submit(signedContinuation);\n            } else {\n                // Single-chain transfer\n                const transferTx = Pact.builder\n                    .execution(\n                        Pact.modules['coin'].transfer(\n                            account,\n                            content.recipient,\n                            amount\n                        )\n                    )\n                    .addSigner(keypair.publicKey, (withCap) => [\n                        withCap(\"coin.GAS\"),\n                        withCap(\"coin.TRANSFER\",\n                            account,\n                            content.recipient,\n                            amount\n                        )\n                    ])\n                    .setMeta({\n                        chainId: fromChain,\n                        senderAccount: account,\n                        gasLimit: 1500,\n                        gasPrice: 0.00000001,\n                        ttl: 28800\n                    })\n                    .setNetworkId(network)\n                    .createTransaction();\n\n                const signedTx = await signTransaction(transferTx, keypair);\n                if (!isSignedTransaction(signedTx)) {\n                    throw new Error(\"Failed to sign transaction\");\n                }\n\n                const localResult = await sourceClient.local(signedTx, {\n                    signatureVerification: true,\n                    preflight: true\n                });\n                if (localResult.result.status !== \"success\") {\n                    throw new Error(`Local verification failed: ${JSON.stringify(localResult.result.error)}`);\n                }\n\n                const submitResult = await sourceClient.submit(signedTx);\n                requestKey = submitResult.requestKey;\n            }\n\n            const explorerUrl = `https://explorer.kadena.io/mainnet/transaction/${requestKey}`;\n            \n            if (callback) {\n                callback({\n                    text: `Successfully transferred ${amount.decimal} KDA ${\n                        isCrossChain ? `from chain ${fromChain} to chain ${toChain}` : `on chain ${fromChain}`\n                    }\\nTransaction ID: ${requestKey}\\nExplorer: ${explorerUrl}`,\n                    content: {\n                        success: true,\n                        requestKey,\n                        amount: amount.decimal,\n                        fromChain,\n                        toChain,\n                        explorerUrl\n                    }\n                });\n            }\n\n            return true;\n\n        } catch (error) {\n            elizaLogger.error(\"Transfer failed:\", error);\n            if (callback) {\n                callback({\n                    text: `Transfer error: ${error.message}`,\n                    content: { error: error.message }\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"send 2 KDA to k:1234 on chain 5\" }\n            },\n            {\n                user: \"{{agent}}\",\n                content: { \n                    text: \"Transferring 2 KDA on chain 5...\",\n                    action: \"TRANSFER_KDA\",\n                    content: {\n                        recipient: \"k:1234\",\n                        amount: 2,\n                        fromChain: \"5\"\n                    }\n                }\n            }\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"transfer 5 KDA from chain 1 to chain 3\" }\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Processing cross-chain transfer...\",\n                    action: \"TRANSFER_KDA\",\n                    content: {\n                        fromChain: \"1\",\n                        toChain: \"3\",\n                        amount: 5,\n                        recipient: \"k:abcd\"\n                    }\n                }\n            }\n        ]\n    ] as ActionExample[][],\n} as Action;","import type {\n    IAgentRuntime,\n    ICacheManager,\n    Memory,\n    Provider,\n    State,\n} from \"@elizaos/core\";\nimport NodeCache from \"node-cache\";\nimport * as path from \"node:path\";\nimport {restoreKeyPairFromSecretKey} from '@kadena/cryptography-utils'\nimport { fetchFungibleChainAccounts, fetchOnChain } from \"../kadenaGraphClient\";\n\n// Provider configuration\nconst PROVIDER_CONFIG = {\n    MAX_RETRIES: 3,\n    RETRY_DELAY: 2000,\n};\n\ninterface WalletPortfolio {\n    totalUsd: string;\n    totalKDA: string;\n}\n\ninterface Prices {\n    kda: { usd: string };\n}\n\nexport class WalletProvider {\n    private cache: NodeCache;\n    private cacheKey = \"kadena/wallet\";\n    account: string;\n\n    constructor(\n        private network:any,\n         account: string,\n        private keypair: any,\n        private cacheManager: ICacheManager\n    ) {\n        this.cache = new NodeCache({ stdTTL: 300 });\n        this.account = account // Cache TTL set to 5 minutes\n    }\n\n    private async readFromCache<T>(key: string): Promise<T | null> {\n        const cached = await this.cacheManager.get<T>(\n            path.join(this.cacheKey, key)\n        );\n        return cached;\n    }\n\n    private async writeToCache<T>(key: string, data: T): Promise<void> {\n        await this.cacheManager.set(path.join(this.cacheKey, key), data, {\n            expires: Date.now() + 5 * 60 * 1000,\n        });\n    }\n\n    private async getCachedData<T>(key: string): Promise<T | null> {\n        // Check in-memory cache first\n        const cachedData = this.cache.get<T>(key);\n        if (cachedData) {\n            return cachedData;\n        }\n\n        // Check file-based cache\n        const fileCachedData = await this.readFromCache<T>(key);\n        if (fileCachedData) {\n            // Populate in-memory cache\n            this.cache.set(key, fileCachedData);\n            return fileCachedData;\n        }\n\n        return null;\n    }\n\n    private async setCachedData<T>(cacheKey: string, data: T): Promise<void> {\n        // Set in-memory cache\n        this.cache.set(cacheKey, data);\n\n        // Write to file-based cache\n        await this.writeToCache(cacheKey, data);\n    }\n\n    async fetchKdaAmountAndPrice(runtime: IAgentRuntime){\n    const network = runtime.getSetting(\"KADENA_NETWORK\") || \"mainnet01\";\n\n    const code = `(n_bfb76eab37bf8c84359d6552a1d96a309e030b71.dia-oracle.get-value \"KDA/USD\" )`\n    const kdaPrice = await fetchOnChain(\"1\", code, network)\n    const result = kdaPrice[0].result\n    const parsed_kda_price = JSON.parse(result);\n    const kda_usd = typeof parsed_kda_price['value'] === \"object\" ? parsed_kda_price['value']['decimal'] : parsed_kda_price['value'];\n    const data = await fetchFungibleChainAccounts(this.account, 'coin', network);\n    let balance = \"0.00\";\n    let value = \"0.00\";\n    \n    if (data && data.length > 0)\n       balance = data.reduce((sum, item) => sum + parseFloat(item.balance), 0).toFixed(2);\n      value = (parseFloat(balance) * kda_usd).toFixed(2);\n    return {\n        kda_usd: kda_usd,\n        balance,\n        value\n    }\n    }\n\n\n    async getFormattedPortfolio(runtime: IAgentRuntime) {\n        try {\n            const portfolio = await this.fetchKdaAmountAndPrice(runtime);\n            return portfolio;\n        } catch (error) {\n            console.error(\"Error generating portfolio report:\", error);\n            return \"Unable to fetch wallet information. Please try again later.\";\n        }\n    }\n}\n\nconst walletProvider: Provider = {\n    get: async (\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ) => {\n        const secretKey = runtime.getSetting(\"KADENA_SECRET_KEY\");\n        const keypair = restoreKeyPairFromSecretKey(secretKey);\n        const account = `k:${keypair.publicKey}`;\n        const network = runtime.getSetting(\"KADENA_NETWORK\");\n\n        try {\n            const provider = new WalletProvider(\n                network,\n                account,\n                keypair,\n                runtime.cacheManager\n            );\n            return provider;\n        } catch (error) {\n            console.error(\"Error in wallet provider:\", error);\n            return null;\n        }\n    },\n};\n\n// Module exports\nexport { walletProvider };\n","import pkg from '@apollo/client';\nconst { ApolloClient, InMemoryCache, gql } = pkg;\n\n\nconst getClient = (network:string) => {\n       if(network==='mainnet01'){\n       return new ApolloClient({\n            uri: 'https://graph.kadena.network/graphql',\n            cache: new InMemoryCache()\n          });\n       }\n       else{\n        return new ApolloClient({\n            uri: 'https://graph.testnet.kadena.network/graphql',\n            cache: new InMemoryCache()\n          });\n       }\n}\n\n// Define the GraphQL query for fungible chain accounts\nconst MY_QUERY = gql`\n  query MyQuery($accountName: String!, $fungibleName: String!) {\n    fungibleChainAccounts(\n      accountName: $accountName\n      fungibleName: $fungibleName\n    ) {\n      balance\n      chainId\n    }\n  }\n`;\n\n// Define the GraphQL query for fetching reserve with variables\nconst FETCH_ONCHAIN_QUERY = gql`\n  query FetchReserve($chainId: String!, $code: String!) {\n    pactQuery(\n      pactQuery: {chainId: $chainId, code: $code}\n    ) {\n      result\n      status\n      error\n    }\n  }\n`;\n\n// Define the GraphQL query for a single fungible chain account\nconst FETCH_FUNGIBLE_CHAIN_ACCOUNT_QUERY = gql`\n  query MyQuery($accountName: String!, $chainId: String!, $fungibleName: String!) {\n    fungibleChainAccount(\n      accountName: $accountName\n      chainId: $chainId\n      fungibleName: $fungibleName\n    ) {\n      balance\n    }\n  }\n`;\n\n// Function to execute the fungible chain accounts query\nexport const fetchFungibleChainAccounts = async (accountName: string, fungibleName: string, network:string) => {\n  try {\n    const client = getClient(network);\n    const { data } = await client.query({\n      query: MY_QUERY,\n      variables: { accountName, fungibleName }\n    });\n    return data.fungibleChainAccounts;\n  } catch (error) {\n    console.error('Error fetching fungible chain accounts:', error);\n    throw error;\n  }\n};\n\n// Function to execute the fetch reserve query\nexport const fetchOnChain = async (chainId: string, code: string, network:string) => {\n  try {\n    const client = getClient(network);\n    const { data } = await client.query({\n      query: FETCH_ONCHAIN_QUERY,\n      variables: { chainId, code }\n    });\n    return data.pactQuery;\n  } catch (error) {\n    console.error('Error fetching reserve:', error);\n    throw error;\n  }\n};\n\n// Function to execute the fungible chain account query\nexport const fetchFungibleChainAccount = async (accountName: string, chainId: string, fungibleName: string, network:string) => {\n  try {\n    const client = getClient(network);\n    const { data } = await client.query({\n      query: FETCH_FUNGIBLE_CHAIN_ACCOUNT_QUERY,\n      variables: { accountName, chainId, fungibleName }\n    });\n    return data.fungibleChainAccount;\n  } catch (error) {\n    console.error('Error fetching fungible chain account:', error);\n    throw error;\n  }\n};","import { createSignWithKeypair, Pact } from \"@kadena/client\";\nimport { fetchOnChain } from \"../kadenaGraphClient\";\nimport { getClient } from \"../constants\";\n\nexport const signTransaction = async (unsignedTx: any, keypair: any) => {\n    const signTransaction = createSignWithKeypair(keypair);\n    const signedTx = signTransaction(unsignedTx);\n    return signedTx;\n  }\n\nexport const getPairAccount = async (dex:string, token:string, network:string) => {\n    const exchange = dex=='kdswap'? 'kdlaunch.kdswap-exchange':'kaddex.exchange';\n    const chainId = dex=='kdswap'? '1':'2';\n    const code = `\n        (let*\n  (\n    (result (${exchange}.get-pair coin ${token}))\n    (kda (at 'reserve (at 'leg0 result)))\n    (token (at 'reserve (at 'leg1 result)))\n  )\n  {\n  \"kda\":kda,\n  \"token\":token,\n  \"account\":(at 'account result)\n  }\n)\n    `\n    const result = await fetchOnChain(chainId, code, network);\n    const account = JSON.parse(result[0].result).account;\n    return account;\n}\n\nexport const isXchainV1 = async (token: string, networkId: string) => {\n    const unsignedTransaction = Pact.builder\n      .execution(`(at 'interfaces (describe-module \"${token}\"))`)\n      .setNetworkId(networkId)\n      .setMeta({ chainId: '1', senderAccount: 'not real' })\n      .createTransaction();\n    const client = getClient(networkId, '1');\n    const response = await client.local(unsignedTransaction, { signatureVerification: false, preflight: false });\n    const isTrue = response.result?.data?.some((moduleInterface) => moduleInterface === 'fungible-xchain-v1');\n    return isTrue;\n  };","import {createClient} from '@kadena/client';\n\nexport const DECIMALS = 12;\n\nexport const getClient = (network: string, chainId: string) => {\n    if (network === 'mainnet01') {\n      return createClient(`https://api.chainweb.com/chainweb/0.0/${network}/chain/${chainId}/pact`);\n    } else {\n      return createClient(`https://api.testnet.chainweb.com/chainweb/0.0/${network}/chain/${chainId}/pact`);\n    }\n  };\n\nexport const DEFAULT_NETWORK = 'mainnet01';\nexport const MOVEMENT_EXPLORER_URL = 'https://explorer.kadena.io';","import { elizaLogger } from \"@elizaos/core\";\nimport {\n    type ActionExample,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport { composeContext, generateObjectDeprecated } from \"@elizaos/core\";\nimport { walletProvider } from \"../providers/wallet\";\nimport { fetchFungibleChainAccounts, fetchFungibleChainAccount } from \"../kadenaGraphClient\";\n\ninterface BalanceContent extends Content {\n    chain?: string;\n    address?: string;\n    token: string;\n    network?: string;\n}\n\nfunction isBalanceContent(content: unknown): content is BalanceContent {\n    elizaLogger.info(\"Validating balance content:\", content);\n    const c = content as BalanceContent;\n    return (\n        (typeof c.chain === \"string\" || typeof c.chain === \"undefined\")  &&\n        typeof c.token === \"string\" &&\n        (typeof c.network === \"string\" || typeof c.network === \"undefined\")\n    );\n}\n\nconst getBalanceTemplate = `\nGet balance request template:\n- Chain: {{chain}}\n- Address: {{address}}\n- Token: {{token}}\n- Network: {{network}}\n\nExample request: \"check my kda balance\"\nExample response:\n\\`\\`\\`json\n{\n    \"address\": \"k:...\",\n    \"token\": \"coin\",\n    \"network\": \"mainnet01\"\n}\n\\`\\`\\`\n\nRules:\n1. Address should start with \"k:\" if provided\n2. Token can be \"kda\" or \"coin\" for KDA\n3. Chain is optional (if omitted, return all chains)\n4. Network defaults to mainnet01 if not specified\n\nRecent messages:\n{{recentMessages}}\n\nExtract and return ONLY the following in a JSON block:\n- chain: The chain ID (optional)\n- address: The wallet address\n- token: The token symbol\n- network: The network identifier (optional)\n`;\n\nexport const getBalance: Action = {\n    name: \"GET_BALANCE\",\n    similes: [\n        \"CHECK_BALANCE\",\n        \"BALANCE\",\n        \"GET_TOKEN_BALANCE\",\n        \"SHOW_BALANCE\",\n        \"CHECK_KDA\",\n    ],\n    triggers: [\n        \"check balance\",\n        \"get balance\",\n        \"check my kda\",\n        \"balance on chain\",\n        \"how much kda\",\n        \"show balance\",\n        \"check\",\n        \"balance\",\n        \"kda balance\",\n        \"my balance\",\n        \"what's my balance\",\n        \"check my kda balance\",\n    ],\n    shouldHandle: (message: Memory) => {\n        const text = message.content?.text?.toLowerCase() || \"\";\n        const should = (\n            (text.includes(\"check\") || text.includes(\"get\") || text.includes(\"balance\") || text.includes(\"how much\")) &&\n            (text.includes(\"kda\") || text.includes(\"coin\") || text.includes(\"my\"))\n        );\n        elizaLogger.debug(\"GET_BALANCE shouldHandle result:\", { should, matchedText: text });\n        return should;\n    },\n    validate: async (_runtime: IAgentRuntime, message: Memory) => {\n        elizaLogger.debug(\"Validating GET_BALANCE for user:\", message.userId);\n        return true;\n    },\n    priority: 1000,\n    description: \"Get balance of a token for the given address on Kadena network\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.info(\"Starting GET_BALANCE handler for:\", message.content?.text);\n\n        try {\n            const walletInfo = await walletProvider.get(runtime, message, state);\n            if (!walletInfo) {\n                throw new Error(\"Failed to initialize wallet provider\");\n            }\n\n            let currentState: State = state ? \n                await runtime.updateRecentMessageState(state) :\n                (await runtime.composeState(message)) as State;\n            \n            state.walletInfo = walletInfo;\n\n            const balanceContext = composeContext({\n                state: currentState,\n                template: getBalanceTemplate,\n            });\n\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: balanceContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (!isBalanceContent(content)) {\n                elizaLogger.info(\"Invalid balance content:\", content);\n                if (callback) {\n                    callback({\n                        text: \"Invalid balance request format\",\n                        content: { error: \"Invalid parameters\" },\n                    });\n                }\n                return false;\n            }\n\n            const network = content.network || runtime.getSetting(\"KADENA_NETWORK\") || \"mainnet01\";\n            const address = content.address.length>64? content.address : walletInfo.account;\n            const token = content.token.toLowerCase();\n            const chain = content.chain;\n\n            if (!address.startsWith(\"k:\")) {\n                throw new Error(\"Address must start with 'k:'\");\n            }\n\n            let response;\n            if (token === \"kda\" || token === \"coin\") {\n                const portfolio = await walletInfo.fetchKdaAmountAndPrice(runtime);\n                \n                if (chain) {\n                    const chainData = await fetchFungibleChainAccounts(address, 'coin', network);\n                    const specificChain = chainData.find((item: any) => item.chainId === chain);\n                    \n                    response = {\n                        address,\n                        chain,\n                        balance: {\n                            token: \"KDA\",\n                            amount: specificChain?.balance || \"0\",\n                            usdValue: specificChain ? \n                                (parseFloat(specificChain.balance) * portfolio.kda_usd).toFixed(2) \n                                : \"0.00\"\n                        }\n                    };\n                } else {\n                    const chainData = await fetchFungibleChainAccounts(address, 'coin', network);\n                    response = {\n                        address,\n                        balances: chainData.map((item: any) => ({\n                            chain: item.chainId,\n                            token: \"KDA\",\n                            amount: item.balance,\n                            usdValue: (parseFloat(item.balance) * portfolio.kda_usd).toFixed(2)\n                        }))\n                    };\n                }\n            } else {\n                if (chain) {\n                    const result = await fetchFungibleChainAccount(address, chain, token, network);\n                    response = {\n                        address,\n                        chain,\n                        balance: {\n                            token,\n                            amount: result?.balance || \"0\"\n                        }\n                    };\n                } else {\n                    const results = await fetchFungibleChainAccounts(address, token, network);\n                    response = {\n                        address,\n                        balances: results.map((item: any) => ({\n                            chain: item.chainId,\n                            token,\n                            amount: item.balance\n                        }))\n                    };\n                }\n            }\n\n            if (callback) {\n                let text = \"\";\n                if (response.balances) {\n                    text = `Balances for ${address}:\\n` + \n                        response.balances.map((bal: any) => \n                            `• ${bal.token} on chain ${bal.chain}: ${bal.amount}` +\n                            (bal.usdValue ? ` ($${bal.usdValue})` : \"\")\n                        ).join(\"\\n\");\n                } else if (response.balance) {\n                    text = `Balance on chain ${response.chain}:\\n` +\n                        `• ${response.balance.token}: ${response.balance.amount}` +\n                        (response.balance.usdValue ? ` ($${response.balance.usdValue})` : \"\");\n                }\n\n                callback({\n                    text: text || \"No balance information found\",\n                    content: response,\n                });\n            }\n\n            return true;\n\n        } catch (error) {\n            elizaLogger.error(\"Balance check failed:\", error);\n            if (callback) {\n                callback({\n                    text: `Error: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"check my kda balance\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Checking your KDA balance...\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        address: \"{{walletAddress}}\",\n                        token: \"coin\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"what's my balance on chain 2?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Retrieving balance for chain 2...\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        chain: \"2\",\n                        token: \"kda\",\n                    },\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;","import { elizaLogger } from \"@elizaos/core\";\nimport {\n    type ActionExample,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport { composeContext, generateObjectDeprecated } from \"@elizaos/core\";\nimport { walletProvider } from \"../providers/wallet\";\nimport { restoreKeyPairFromSecretKey } from \"@kadena/cryptography-utils\";\nimport { getClient } from \"../constants\";\nimport { Pact, isSignedTransaction } from '@kadena/client';\nimport { getPairAccount, signTransaction } from \"./utils\";\n\nexport interface SwapContent extends Content {\n    fromToken: string;\n    toToken: string;\n    amount: string | number;\n    platform: string;\n}\n\nfunction isSwapContent(content: unknown): content is SwapContent {\n    elizaLogger.debug(\"Validating swap content:\", content);\n    return (\n        typeof (content as SwapContent).fromToken === \"string\" &&\n        typeof (content as SwapContent).toToken === \"string\" &&\n        (typeof (content as SwapContent).amount === \"string\" ||\n            typeof (content as SwapContent).amount === \"number\") &&\n        typeof (content as SwapContent).platform === \"string\"\n    );\n}\n\nconst swapTemplate = `You are processing a token swap request. Extract the fromToken, toToken, amount, and platform from the message.\n\nExample request: \"can you swap 1 kda to free.cyberfly_token on kdswap\"\nExample response:\n\\`\\`\\`json\n{\n    \"fromToken\": \"kda\",\n    \"toToken\": \"free.cyberfly_token\",\n    \"amount\": \"1\",\n    \"platform\": \"kdswap\"\n}\n\\`\\`\\`\n\nRules:\n1. The fromToken and toToken are token symbols.\n2. The amount is typically a number less than 100\n3. The platform is either \"kdswap\" or \"mercatus\"\n4. Return exact values found in the message\n\nRecent messages:\n{{recentMessages}}\n\nExtract and return ONLY the following in a JSON block:\n- fromToken: The token symbol to swap from\n- toToken: The token symbol to swap to\n- amount: The number of tokens to swap\n- platform: The platform to use for the swap\n\nReturn ONLY the JSON block with these four fields.`;\n\nexport const swapToken: Action = {\n    name: \"SWAP_TOKEN\",\n    similes: [\n        \"SWAP_TOKEN\",\n        \"EXCHANGE_TOKEN\",\n        \"TRADE_TOKEN\",\n        \"SWAP_TOKENS\",\n        \"EXCHANGE_TOKENS\",\n        \"TRADE_TOKENS\",\n    ],\n    triggers: [\n        \"swap kda\",\n        \"swap 1 kda\",\n        \"exchange kda\",\n        \"swap token\",\n        \"exchange token\",\n        \"can you swap\",\n        \"please swap\",\n        \"swap\",\n    ],\n    shouldHandle: (message: Memory) => {\n        const text = message.content?.text?.toLowerCase() || \"\";\n        return (\n            text.includes(\"swap\") &&\n            text.includes(\"kda\") &&\n            text.includes(\"to\") &&\n            (text.includes(\"kdswap\") || text.includes(\"mercatus\"))\n        );\n    },\n    validate: async (_runtime: IAgentRuntime, message: Memory) => {\n        elizaLogger.debug(\n            \"Starting swap validation for user:\",\n            message.userId\n        );\n        elizaLogger.debug(\"Message text:\", message.content?.text);\n        return true; // Let the handler do the validation\n    },\n    priority: 1000, // High priority for swap actions\n    description:\n        \"Swap tokens from one type to another on the Kadena network\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.debug(\"Starting SWAP_TOKEN handler...\");\n        elizaLogger.debug(\"Message:\", {\n            text: message.content?.text,\n            userId: message.userId,\n            action: message.content?.action,\n        });\n\n        try {\n            const secretKey = runtime.getSetting(\"KADENA_SECRET_KEY\");\n            elizaLogger.debug(\n                \"Got private key:\",\n                secretKey ? \"Present\" : \"Missing\"\n            );\n\n            const network = runtime.getSetting(\"KADENA_NETWORK\") || \"mainnet01\"\n            elizaLogger.debug(\"Network config:\", network);\n          \n            const keypair = restoreKeyPairFromSecretKey(secretKey);\n            const account = `k:${keypair.publicKey}`;\n            elizaLogger.debug(\n                \"Created Kadena account:\",\n                account\n            );\n\n            const walletInfo = await walletProvider.get(\n                runtime,\n                message,\n                state\n            );\n            state.walletInfo = walletInfo;\n            let currentState: State;\n            if (!state) {\n                currentState = (await runtime.composeState(message)) as State;\n            } else {\n                currentState = await runtime.updateRecentMessageState(state);\n            }\n\n            const swapContext = composeContext({\n                state: currentState,\n                template: swapTemplate,\n            });\n\n            // Generate swap content\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: swapContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // Validate swap content\n            if (!isSwapContent(content)) {\n                console.error(\"Invalid content for SWAP_TOKEN action.\");\n                if (callback) {\n                    callback({\n                        text: \"Unable to process swap request. Invalid content provided.\",\n                        content: { error: \"Invalid swap content\" },\n                    });\n                }\n                return false;\n            }\n\n            console.log(\n                `Swapping: ${content.amount} ${content.fromToken} to ${content.toToken} on ${content.platform}`\n            );\n\n            const chainId = content.platform.toLowerCase() === \"kdswap\" ? \"1\" : \"2\";\n            const pair_account = await getPairAccount(content.platform,content.toToken,network)\n            elizaLogger.info(\"Pair account:\", pair_account);    \n            const unsignedTransaction = Pact.builder\n            .execution(\n                `(${content.platform=='kdswap'? 'kdlaunch.kdswap-exchange':'kaddex.exchange'}.swap-exact-in (read-decimal 'token0Amount) (read-decimal 'token1AmountWithSlippage) [${content.fromToken.toLowerCase()=='kda'?'coin':content.fromToken.toLowerCase()} ${content.toToken.toLowerCase()=='kda'?'coin':content.toToken.toLowerCase()}] \"${account}\" \"${account}\" (read-keyset 'ks))`\n            )\n            .addSigner(account.slice(2), (withCapability) => [\n              // add necessary coin.GAS capability (this defines who pays the gas)\n              withCapability(content.platform=='kdswap'? 'kdlaunch.kdswap-gas-station.GAS_PAYER':'kaddex.gas-station.GAS_PAYER', content.platform=='kdswap'? 'free-gas':'kaddex-free-gas', { int: 1 }, 1.0),\n              // add necessary coin.TRANSFER capability\n              withCapability(`${content.fromToken.toLowerCase()=='kda'? 'coin':content.fromToken.toLowerCase()}.TRANSFER`, account, pair_account, Number(content.amount)),\n            ])\n            .addData('ks',{keys:[account.slice(2)], pred:'keys-all'})\n            .addData('token0Amount', Number(content.amount))\n            .addData('token1AmountWithSlippage', 0)\n            .setMeta({ chainId, senderAccount: content.platform=='kdswap'? 'kdswap-gas-payer':'kaddex-free-gas' })\n            .setNetworkId(network)\n            .createTransaction();\n      \n          const signedTx = await signTransaction(unsignedTransaction, keypair);\n          const client = getClient(network, chainId);  \n            const localResponse = await client.local(signedTx);\n            if (localResponse.result.status === 'success') {\n              const transactionDescriptor = await client.submit(signedTx);\n              const explorerUrl = `https://explorer.kadena.io/mainnet/transaction/${transactionDescriptor.requestKey}`;\n              elizaLogger.debug(\"Swap successful:\", {\n                  hash: transactionDescriptor.requestKey,\n                  amount: content.amount,\n                  fromToken: content.fromToken,\n                  toToken: content.toToken,\n                  platform: content.platform,\n                  explorerUrl,\n              });\n  \n              if (callback) {\n                  callback({\n                      text: `Submitted swap ${content.amount} ${content.fromToken} to ${content.toToken} on ${content.platform}\\nTransaction: ${transactionDescriptor.requestKey}\\nView on Explorer: ${explorerUrl}`,\n                      content: {\n                          success: true,\n                          hash: transactionDescriptor.requestKey,\n                          amount: content.amount,\n                          fromToken: content.fromToken,\n                          toToken: content.toToken,\n                          platform: content.platform,\n                          explorerUrl,\n                      },\n                  });\n              }\n            }\n            else{\n                if (callback) {\n                    callback({\n                        text: `Error: ${localResponse.result.error.message}  on swap ${content.amount} ${content.fromToken} to ${content.toToken} on ${content.platform}\\n`,\n                        content: {\n                            success: false,\n                            amount: content.amount,\n                            fromToken: content.fromToken,\n                            toToken: content.toToken,\n                            platform: content.platform,\n                        },\n                    });\n                }\n            }\n          \n\n            return true;\n        } catch (error) {\n            console.error(\"Error during token swap:\", error);\n            if (callback) {\n                callback({\n                    text: `Error swapping tokens: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"can you swap 1 kda to free.cyberfly_token on kdswap\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll help you swap 1 kda to free.cyberfly_token on kdswap...\",\n                    action: \"SWAP_TOKEN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"swap 1 kda to free.cyberfly_token on mercatus\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Processing token swap...\",\n                    action: \"SWAP_TOKEN\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import type { Plugin } from \"@elizaos/core\";\nimport {transferToken} from \"./actions/transfer\";\nimport  {getBalance} from \"./actions/getbalance\";\nimport { swapToken } from \"./actions/swap\";\nimport { WalletProvider, walletProvider } from \"./providers/wallet\";\n\nexport { WalletProvider, transferToken, getBalance };\n\nexport const kadenaPlugin: Plugin = {\n    name: \"kadena\",\n    description: \"Kadena Blockchain Plugin for Eliza\",\n    actions: [getBalance, transferToken, swapToken],\n    evaluators: [],\n    providers: [walletProvider],\n};\n\nexport default kadenaPlugin;\n"],"mappings":"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","names":["restoreKeyPairFromSecretKey","Pact","getClient","signTransaction","networkId","getClient","restoreKeyPairFromSecretKey","getClient","Pact","elizaLogger","ModelClass","composeContext","generateObjectDeprecated","elizaLogger","composeContext","generateObjectDeprecated","ModelClass","elizaLogger","ModelClass","composeContext","generateObjectDeprecated","restoreKeyPairFromSecretKey","Pact","elizaLogger","restoreKeyPairFromSecretKey","composeContext","generateObjectDeprecated","ModelClass","Pact","getClient"]}